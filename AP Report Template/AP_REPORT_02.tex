
\documentclass[a4paper, oneside, 11pt]{report}
\usepackage{epsfig,pifont,float,multirow,amsmath,amssymb}
\newcommand{\mc}{\multicolumn{1}{c|}}
\newcommand{\mb}{\mathbf}
\newcommand{\mi}{\mathit}
\newcommand{\oa}{\overrightarrow}
\newcommand{\bs}{\boldsymbol}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}
\usepackage{algorithm}
\usepackage{algorithmic}
\topmargin = 0pt
\voffset = -80pt
\oddsidemargin = 15pt
\textwidth = 425pt
\textheight = 750pt

\begin{document}

\begin{titlepage}
\begin{center}
\rule{12cm}{1mm} \\
\vspace{1cm}
{\large  CMP-6048A/7009A Advanced Programming} %Delete as appropriate
\vspace{7.5cm}
\\{\Large Project Report - Due 12 January 2026 before 15:00}
\vspace{1.5cm}
\\{\LARGE Maths Interpreter software} % You can add to this title of modify it if you wish
\vspace{1.0cm}
\\{\Large Group members: \\ Mason Buckle and Anthony De Cruz.\ }
\vspace{10.0cm}
\\{\large School of Computing Sciences, University of East Anglia}
\\ \rule{12cm}{0.5mm}
\\ \hspace{8.5cm} {\large Version 2.0}
\end{center}
\end{titlepage}


\setcounter{page}{1}
%\pagenumbering{roman}
%\newpage


\begin{abstract}
This report documents both the design and implementation of a custom mathematical interpreter and graphing calculator. The primary objective was to o develop a capable maths interpreter and GUI with a user friendly interface. The development methodology adopted a hybrid programming approach,
using the functional paradigm of F Sharp for the interpreter logic and the object oriented nature of C Sharp for the user interface.
\newline
\newline
The project evolved through a series of iterative stages. Early development focuses on creating a foundational GUI, this was expanded to support advanced interpreter features such as 
operator precedence, floating point arithmetic and variable storage using a symbol table. An external plotting library was used to enable the visualisation of linear and polynomial functions.
\newline
\newline
The final result is a fully functional mathematical software. It demonstrates successful compatibility between two languages, with the front end handling the user input and the back-end using lexical analysis and evaluation.
The inclusion of the optional features: control flow and booleans represents the flexibility of the project.
\end{abstract}

\chapter{Introduction}
\label{chap:intro}

\section{Project statement}
This project focuses on developing a desktop maths software solution with GUI that uses an interpreter. This project play an important role in areas such as education and research, offering a platform to test mathematical concepts easier. F\# is used for the interpreter and C\# (WPF) is used for the GUI.
The software has been developed over a period of 4 months and was split into sprints (see Development History \ref{Chap:DevHist}). We accomplished this via modular design and 
testing each part at every stage. Git was used for version control and Github's kanban board feature was used to break down tasks as well as the platforms workflow feature for automated test pipelines. The final deliverable is a capable desktop maths software solution with a GUI that successfully links a maths interpreter with a user-friendly interface.


\section{Aims and objectives}
The main overarching goal of the project is to develop a capable maths interpreter and GUI with a user friendly interface, this is broken down further into the main project objectives below: 

\begin{center}
{\large Project Objectives} \\[0.5em] 
\rule{0.6\textwidth}{0.4pt} \\[1em]   
\begin{minipage}{0.6\textwidth}       
\begin{enumerate}
    \item To implement a interpreter capable of correctly interpreting and executing arithmetic expressions, managing variable assignment and executing control flow loops.
    \item To create a responsive GUI that is capable of accepting user commands, displaying results and displaying errors
    \item To create a plotting section in the GUI to plot both linear and polynomial functions and have interactive capabilities such as zooming in and out.
\end{enumerate}
\end{minipage}
\end{center}

\begin{table}[h]
\caption{(Functional) MoSCoW}
\begin{center}
\begin{tabular}{|p{1in}|p{2in}|p{2.5in}|} \hline
Priority & Task & Comments \\ \hline \hline
\multirow{3}{1in}{Must}
& To implement a interpreter capable of correctly parsing and executing arithmetic expressions & Is the most essential task within the brief \\ \cline{2-3}
& To implement variable management allowing assignment of values to variables and to use variables in expressions & An important feature needed to allow polynomials later in the project  \\ \cline{2-3}
& To develop a basic GUI that has a command prompt for user input and a text field for displaying results or errors & Essential for user interaction and error reporting\\ \cline{2-3}
& To be able to plot both linear and polynomial functions within the GUI & The main visualization requirement, needed to visualise mathematical functions. \\ \hline \hline
\multirow{3}{1in}{Should}
& To extend the interpreter with control flow & Implementing for loops \\ \cline{2-3}
& To implement interactive plotting features E.g. zooming in and out & Enhances the user experience by allowing the user to explore the plane  \\ \hline \hline
\multirow{3}{1in}{Could}
& To visualize the parse tree  &  Helpful for debugging the parsing logic\\ \cline{2-3}
& To implement GPU acceleration & To optimise the rendering of the grid line during real-time interaction \\ \hline \hline
\multirow{3}{1in}{Should not}
& To implement a compiler/transpiler & Overly ambitious given the development time. \\ \cline{2-3}
& To implement advanced mathematical features (differentiation/integration) & We wanted to ensure the core interpreter was robust and also dropped to the development time. \\ \hline
\end{tabular}
\label{Table1}
\end{center}
\end{table}


\chapter{Background}
The development of maths platforms and plotting software has a lot of history, ranging from early command line maths tools to web based educational tools.
Desmos is one of such tools that represents a modern approach to mathematical softwate. Desmos was launched in 2011, it is a web-based graphing calculator built mainly in Javascript \cite{Desmos:2023}.
It mainly focuses on graphing and visualization allowing a user to input complex equations instantly in a browser, furthermore it is a great educational tool allowing students to get instant feedback making it more engaging to learn.
\newline
\newline
Matlab is a programming and numeric computing platform used to analyze data, develop algorithms and create models \cite{Matlab:2023}. Matlab was originally released in the late 1970's by Cleve Moler, it was designed to be a interactive matrix calculator \cite{Wiki:MATLAB}.
Its launch as a commercial product in 1984 by MathWorks gave matlab a significant redesign transforming it into what it is today allowing not only matrix operations but also plotting capabilities and algorithm implementation.
\newline
\newline
The project follows some of the methodologies outlined in Crafting Interpreters by Robert Nystrom \cite{Nystrom:2021}. Nystrom's interpreter is implemented in java using an object oriented approach whilst this project adapts those concepts into a functional paradigm using F\#. The Abstract SyntaxTree (AST) was  implemented using F\# Discriminated Unions. This approach allowed the data structure to mirror our Backus-Naur Form (BNF) directly.
\newline
\newline
The graphical user interface (GUI) was developed using Window Presentation Foundation (WPF) \cite{WPF:2023}. The C\# frontend invokes the F\# lexer and parser functions directly. One of the challenges faced in this was converting functional data types such as F\#List into C\# arras for the UI logic.
\newline
\newline
The graphic library Oxyplot was used for the plotting capabilities. Oxyplot is an open source .NET plotting library \cite{OxyPlot:2023}. It handles the rendering of plot points generated by our interpreter, allowing the frontend To
display graphs based on the user input.

\chapter{Development History}\label{Chap:DevHist}

\section{Sprint 1: Basic expressions and GUI}
This was the starting point of the project, focusing on the development of a Graphic User Interface (GUI) using Window Presentation Format (WPF). A challenge 
encountered during this phase was the teams unfamiliarity with the WPF framework. This was overcome by consulting the technical documentation \cite{WPF:2023}. 
The result was a basic functional frontend capable of accepting basic user input.
\subsection{Grammar in BNF}
\begin{verbatim}
<E>    ::= <T> <Eopt>
<Eopt> ::= "+" <T> <Eopt> | "-" <T> <Eopt> | <empty>
<T>    ::= <NR> <Topt>
<Topt> ::= "*" <NR> <Topt> | "/" <NR> <Topt> | <empty>
<NR>   ::= "Num" <value> | "(" <E> ")"
\end{verbatim}

\subsection{Basic GUI}
We used WPF with C\# to develop a basic GUI - see Figure \ref{gui01}.

\begin{figure}[H]
\begin{center}
\includegraphics[width=0.9 \columnwidth]{GUI_01.png}
\caption{A very basic GUI!}
\label{gui01}
\end{center}
\end{figure}

\subsection{Testing}
A summary of the critical test cases is presented in Table \ref{tab:test_summary}. These results represent a subset of the complete test suite found in Table \ref{TableTest1} (Appendix \ref{app:test}).

\begin{table}[ht]
    \centering
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Expression} & \textbf{ResE} & \textbf{ResA} & \textbf{Status} \\
        \hline
        \texttt{9 - 3 - 2} & \texttt{4} & \texttt{4} & Pass \\
        \texttt{5 + 3} & \texttt{8} & \texttt{8} & Pass \\
        \texttt{+ 3} & \texttt{Error} & \texttt{Syntax Error} & Pass \\
        \hline
    \end{tabular}
    \caption{Key testing outcomes (Subset of full data in Table \ref{Table2}).}
    \label{tab:test_summary}
\end{table}

\section{Sprint 2: Adding unary minus, powers and mod}
Building upon the basic arithmetic implemented in Sprint 1, this sprint focused on expanding the interpreter's mathematical capable to support more complex expressions.
The main objective was to implement exponents(\verb|^|), the modulus operator (\%) and unary minus. There were two major issues in this sprint which were operator precedence and
unary minus representing both subtraction and negation. These were overcome by restructuring the parser to handle operator precedence correctly and changing the parser logic to distinguish between subtraction and negation.
\subsection{BNF}
\begin{verbatim}
<E>    ::= <T> <Eopt> 
<Eopt> ::= "+" <T> <Eopt> | "-" <T> <Eopt> | <empty>
<T>    ::= <U> <Topt>
<Topt> ::= "*" <U> <Topt> | "/" <U> <Topt> | "%" <U> <Topt> | <empty>
<U>    ::= "-" <U> | <P>
<P>    ::= <NR> <Popt>
<Popt> ::= "^" <NR> <Popt> | <empty>
<NR>   ::= "Num" <value> | "(" <E> ")"
\end{verbatim}

\subsection{Updated GUI}

\begin{figure}[H]
\begin{center}
\includegraphics[width=0.9 \columnwidth]{GUI_02.png}
\caption{Updated GUI}
\label{gui02}
\end{center}
\end{figure}

\begin{figure}[H]
\begin{center}
\includegraphics[width=0.9 \columnwidth]{GUI_03.png}
\caption{Tutorial Page}
\label{gui03}
\end{center}
\end{figure}

\subsection{Testing}
A summary of the critical test cases is presented in Table \ref{tab:test_summary}. These results represent a subset of the complete test suite found in Table \ref{Table2} (Appendix \ref{app:test}).

\begin{table}[ht]
    \centering
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Expression} & \textbf{ResE} & \textbf{ResA} & \textbf{Status} \\
        \hline
        \texttt{$10/3$} & \texttt{3} & \texttt{3} & Pass \\
        \texttt{10 - - 2} & \texttt{12} & \texttt{12} & Pass \\
        \texttt{$2 * 3 ^ 2$} & \texttt{18} & \texttt{18} & Pass \\
        \hline
    \end{tabular}
    \caption{Key testing outcomes (Subset of full data in Table \ref{Table2}).}
    \label{tab:test_summary}
\end{table}

\section{Sprint 3: Added floating point}
Sprint 3 addressed the limitation of integer only arithmetic by introducing floating point numbers.
This was done by modifying the lexer to recognize decimal points and parse fractional values. There was also an update 
to the BNF, splitting number into distinct integer (\verb|<IN>|) and Float (\verb|<FL>|) definitions.
\subsection{BNF}
\begin{verbatim}
<E>    ::= <T> <Eopt>
<Eopt> ::= "+" <T> <Eopt> | "-" <T> <Eopt> | <empty>
<T>    ::= <P> <Topt>
<Topt> ::= "*" <P> <Topt> | "/" <P> <Topt> | "%" <P> <Topt> | <empty>
<P>    ::= <U> <Popt>
<Popt> ::= "^" <U> <Popt> | <empty>
<U>    ::= "-" <U> | <NM>
<NM>   ::= <IN> | <FL> | "(" <E> ")"
<IN>   ::= <digit>+
<FL>   ::= <digit>+ "." <digit>+
\end{verbatim}

\subsection{Testing}
A summary of the critical test cases is presented in Table \ref{tab:test_summary}. These results represent a subset of the complete test suite found in Table \ref{Table2} (Appendix \ref{app:test}).

\begin{table}[ht]
    \centering
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Expression} & \textbf{ResE} & \textbf{ResA} & \textbf{Status} \\
        \hline
        \texttt{10/3.0} & \texttt{3.333} & \texttt{3.333} & Pass \\
        \texttt{3 + 1.1} & \texttt{12} & \texttt{12} & Pass \\
        \texttt{$2 ^{1.1}$} & \texttt{2.144} & \texttt{2.144} & Pass \\
        \hline
    \end{tabular}
    \caption{Key testing outcomes (Subset of full data in Table \ref{Table2}).}
    \label{tab:test_summary}
\end{table}
\section{Sprint 4: Added linear plotting}
Sprint 4 focused on transforming the project into a visual graphic tool. The main objective was the integration with the OxyPlot library \cite{OxyPlot:2023} into the frontend.
The C\# was significantly updated to translate constant functions e.g. y=5, this established a good framework for more complex visualisations in later springs.
\subsection{Updated GUI}
\begin{figure}[H]
\begin{center}
\includegraphics[width=0.9 \columnwidth]{GUI_04.png}
\caption{Plot GUI}
\label{gui04}
\end{center}
\end{figure}

\begin{figure}[H]
\begin{center}
\includegraphics[width=0.9 \columnwidth]{GUI_05.png}
\caption{Plot GUI with test plot}
\label{gui04}
\end{center}
\end{figure}

\section{Sprint 5: Added polynomial plotting}
The focus of sprint 5 was to extend the interpreter's capabilities to support variables and polynomial functions.
To achieve this a symbol table was integrated.
\subsection{BNF}
\begin{verbatim}
STATEMENTS
<STA>    ::= ( <ASN> | <PLT> | <PTR> ) ";"
           | <STA> <STA>
            | <empty>
<ASN>    ::= "let" <SYM> "=" <NM>
<PLT>    ::= "plot" <NM> <PLTopt>
<PLTopt> ::= "," <NM> <PLopt> | <empty>
<PRT>    ::= "print" <NM>
<SYM>    ::= <alpha+>

EXPRESSIONS
<E>    ::= <T> <Eopt>
<Eopt> ::= "+" <T> <Eopt> | "-" <T> <Eopt> | <empty>
<T>    ::= <P> <Topt>
<Topt> ::= "*" <P> <Topt> | "/" <P> <Topt> | "%" <P> <Topt> | <empty>
<P>    ::= <U> <Popt>
<Popt> ::= "^" <U> <Popt> | <empty>
<U>    ::= "-" <U> | <NM>
<NM>   ::= <IN> | <FL> | <SYM> | "(" <E> ")"
<IN>   ::= <digit+>
<FL>   ::= <digit+> "." <digit+>
\end{verbatim}

\subsection{Updated GUI}
\begin{figure}[H]
\begin{center}
\includegraphics[width=0.9 \columnwidth]{GUI_06.png}
\caption{Plot GUI with a parabola}
\label{gui04}
\end{center}
\end{figure}

\begin{figure}[H]
\begin{center}
\includegraphics[width=0.9 \columnwidth]{GUI_07.png}
\caption{Plot GUI with multiple lines and parabola}
\label{gui04}
\end{center}
\end{figure}

\chapter{Final deliverable}\label{Impl}

The chapter will cover the final deliverable version of the project, including BNF and code architecture.

\section{Final BNF}

\begin{verbatim}
STATEMENTS
<PROG>  ::= <STA> <PROG> | <empty>
<STA>   ::= <WHL> | <IF> | <ASN> | <PLT> | <PRT>
<WHL>   ::= "while" <BE> "{" <PROG> "}"
<IF>    ::= "if" <BE> "{" <PROG> "}"
<ASN>   ::= "let" <SYM> "=" <BE> ";" | "func" <SYM> "=" <BE> ";"
<PLT>   ::= "plot" <BE> ";"
<PRT>   ::= "print" <BE> ";" | <BE> ";"    // Print top level expressions.
<SYM>   ::= <alpha+>

EXPRESSIONS
<BE>    ::= <BU> <BEopt>
<BEopt> ::= "and" <BU> <BEopt> | "or" <BU> <BEopt> | <empty>
<BU>    ::= "!" <BU> | <BT>
<BT>    ::= <E> <BTopt>
<BTopt> ::= "==" <E> <BTopt>
          | "!=" <E> <BTopt>
          | ">" <E> <BTopt>
          | "<" <E> <BTopt>
          | <empty>
<E>     ::= <T> <Eopt>
<Eopt>  ::= "+" <T> <Eopt> | "-" <T> <Eopt> | <empty>
<T>     ::= <P> <Topt>
<Topt>  ::= "*" <P> <Topt> | "/" <P> <Topt> | "%" <P> <Topt> | <empty>
<P>     ::= <U> <Popt>
<Popt>  ::= "^" <U> <Popt> | <empty>
<U>     ::= "-" <U> | <NM>
<NM>    ::= <VL> | <SYM> | "(" <BE> ")"    // Where SYM is defined in symbol table.
<VL>    ::= <IN> | <FL>    // Separate literal value simplifies implementation.
<IN>    ::= <digit+>
<FL>    ::= <digit+> "." <digit+>

KEY
STATEMENTS
PROG  -> Program
STA   -> Statement
ASN   -> Variable/Function Assignment
PLT   -> Plot
PTR   -> Print
SYM   -> Symbol
EXPRESSIONS
BE    -> Boolean Expression
BEopt -> Boolean Expression/Optional
BU    -> Boolean Unary
BT    -> Boolean Term
E     -> Expression
Eopt  -> Expression/Optional
T     -> Term
Topt  -> Term/Optional
P     -> Power
Popt  -> Power/Optional
U     -> Unary
NM    -> Number
VL    -> Value
IN    -> Integer
FL    -> Floating Point
\end{verbatim}

This complete BNF models our final interpreter's capabilities. The top of the structure includes statements which are designed to run sequentially with the recursive $PROG$ type. Statements are broken down into several types where each one is denoted with a string keyword and at least one argument.
\newline
\newline
Loops $WHL$ allow the user to execute $PROG$ blocks repeatedly as long as a condition $BE$ is met. Ifs $IF$ follow effectively the same behaviour without the repetition. A condition is met if the expression resolves as any non zero value. The language lacks a dedicated boolean type for simplicity.
\newline
\newline
Assignments $ASN$ allow variables to be set with $let =$ and functions (effectively expressions that are only fully evaluated at plot time) to be set with $func =$.
\newline
\newline
Plot $PLT$ is a special statement that allows the user to provide an expression to be used to generate a plot sequence. During execution, the given expression is resolved for each step in the plotting sequence. For each step, the symbol table is modified such that the special variable $x$ is set to the plot point X, where Y is the result of the expression. The implementation code can be found in Fig.\ref{codeSnip1}. When a plot is made, a message is written to the output text stream.
\newline
\newline
The print statement $PRT$ writes the given expression result to the output text stream.
\newline
\newline
After statements come expressions. The expression hierarchy is structured in such an order as to facilitate the desirable order of execution in a recursive descent parser. Boolean expressions all resolve to return either an integer or float value 1 or 0, depending on the logical result. Boolean expressions $BE$ $and$ and $or$ are resolved after boolean unary $BU$ $!$ and boolean terms $BT$ $==$, $>$ in order to get the conventionally expected behaviour from a condition such as \text{5 != 3 and 2 == 1 - 3} found in other languages.
\newline
\newline
After boolean expressions come the rest of the arithmetic expressions. In order to produce mathematically correct operator precedence, unary minuses $U$ are resolved last, followed by powers $P$, terms $T$ which includes $*$, $/$, and $\%$ whilst expressions $E$ with $+$ and $-$ are resolved last.
\newline
\newline
Finally numbers $NM$ contain our literal values $VL$, symbol $SYM$ strings and bracketed $BE$. Integers $IN$ and floats $FL$ are wrapped by their own type for the sake of ease of implementation. $SYM$ strings are used as variable and function identifies to lookup and write to the symbol table. $BE$ are resolved before other kinds of expressions here in order to set appropriate bracketed precedence.

\section{Final GUI}

Fig.\ref{guiFinal02} shows a screenshot of the final application running a simple program, plotting several lines. The program being run demonstrates the full capabilities of the final interpreter, demonstrating variables, functions, loops, conditionals, arithmetic and plotting.

\begin{figure}[H]
%\begin{center}
\includegraphics[width=0.9 \columnwidth]{GUI_Final.png}
\caption{The final application.}
\label{guiFinal02}
%\end{center}
\end{figure}

Fig.\ref{guiFinal03} shows a screenshot of the final application running the same program in interference mode. This was a mode of rendering added to facilitate the generate of interference patterns based on the combination of every wave or line being plotted at once. Although not directly described in the brief, this feature was added at the end as the development cost was considered minimal. This style of rendering can be toggled via a simple labelled checkbox. This capability would have significant use cases in the fields of wave processing and communications.

\begin{figure}[h]
%\begin{center}
\includegraphics[width=0.6 \columnwidth]{GUI_Inter.png}
\caption{The final application. The program from fig.\ref{guiFinal02} rendering in interference mode.}
\label{guiFinal03}
%\end{center}
\end{figure}

\section{Code architecture}

The F\# interpreter is implemented as a recursive descent parser which is covered in further detail in the following section. BNF specific nodes are covered in the previous section. The parser is implemented as a function that returns an AST made up of nodes defined as type unions. This AST is then passed into the executor which then traverses the AST to resolve the program.
\newline
\newline
Fig.\ref{class} shows a UML class diagram of the GUI. In order to keep the front end as minimal as possible, it consists only of 2 window classes and 2 wrapper classes for the F\# interpreter and plot modelling, named $InterpreterController$ and $PlotController$ respectively. The application was architected with an MVC style model was attempted in order to follow software engineering best practices, forming abstract interfaces that encapsulate each area of responsibility and facilitate smooth automated testing.
\newline
\newline
$InterpreterController$ worked as the interface between the F\# interpreter and the C\# frontend, cleaning abstracting away any language interop difficulties. Plot data rendering and modelling was provided by Oxyplot's $PlotModel$ and $LineSeries$ types.

\begin{figure}[H]
%\begin{center}
\includegraphics[width=1.0 \columnwidth]{ClassUML.png}
\caption{The GUI UML class diagram. Note that $System.Windows.Window$ is provided by WPF and $Oxyplot.Core.PlotModel$ is provided by Oxyplot.}
\label{class}
%\end{center}
\end{figure}

\section{Algorithms}

The lexer in Fig.\ref{lexerAlgo} processes the source input in a single left-to-right pass, repeatedly examining the next character (or sequence of characters) to determine the appropriate token to generate. Keywords and operators are detected first using fixed string matches to ensure correct precedence over identifiers. Numbers are recognised by scanning consecutive digits into a single value, while identifiers are formed by consuming contiguous alphabetic characters. For each construct, a corresponding token is appended to the output list. This is a simple and efficient lexer for use with a recursive descent parser.

\begin{figure}[H]
\begin{algorithm}[H]
\caption{Lexer algorithm}
\begin{algorithmic}[1]
\STATE $\mathit{tokens} \gets [\ ]$
\STATE $\mathit{input} \gets \textsc{ToCharList}(\mathit{source})$
\WHILE{$\mathit{input}$ is not empty}
    \STATE $c \gets \textsc{Head}(\mathit{input})$
    \IF{$\mathit{input}$ starts with a keyword or operator}
        \STATE $\mathit{tokens}.\textsc{Append}(\textsc{Token})$
        \STATE \textsc{Consume}$(n)$
    \ELSIF{$c$ is a digit}
        \STATE $(\mathit{value}, \mathit{rest}) \gets \textsc{ScanNumber}(\mathit{input})$
        \STATE $\mathit{tokens}.\textsc{Append}(\mathit{value})$
        \STATE $\mathit{input} \gets \mathit{rest}$
    \ELSIF{$c$ is alphabetic}
        \STATE $(\mathit{name}, \mathit{rest}) \gets \textsc{ScanIdentifier}(\mathit{input})$
        \STATE $\mathit{tokens}.\textsc{Append}(\mathit{name})$
        \STATE $\mathit{input} \gets \mathit{rest}$
    \ELSIF{$c = \#$}
        \STATE $\mathit{input} \gets \textsc{SkipComment}(\mathit{input})$
    \ELSIF{$c$ is whitespace}
        \STATE \textsc{Consume}$(1)$
    \ELSE
        \STATE \textsc{RaiseSyntaxError}$(c)$
    \ENDIF
\ENDWHILE
\STATE \textbf{return} $\mathit{tokens}$
\end{algorithmic}
\end{algorithm}
\caption{Simplified lexer algorithm for tokenising source input}
\label{lexerAlgo}
\end{figure}


The pseudocode found in Fig.\ref{compressedParser} is designed to demonstrate the logical flow of a recursive descent parser. Here, we can see the function $ParseExpression$ looks to parse a single expression node, calling $ParseNextExpression$ on it's left hand side and $ParseOperand$ on it's right hand side first before creating it's own node. This means that when an expression is first parsed, the left is always resolved first, trickling down to it's terminal literal. The right hand side is then parsed. If there is a matching operator, the right hand operand is then evaluated and the cycle continues. If there is no matching operator, the algorithm will continue to bubble up until one is found or the program ends.
\newline
\newline
This method of traversal depicts both token parsing for building an AST as well as AST traversal for execution and is how both passes of the interpreter are implemented.

\begin{figure}[H]
\begin{algorithm}[H]
\caption{Recursive descent parser demonstrating recursion and precedence}
\begin{algorithmic}[1]
\STATE \textbf{function} ParseExpression(tokens)
\STATE \quad $(left, tokens) \gets \textsc{ParseNextExpression}(tokens)$
\STATE \quad $(right, tokens) \gets \textsc{ParseOperand}(tokens)$
\STATE \quad \textbf{return} $(\textsc{NewNode}(left, right), tokens)$
\STATE
\STATE \textbf{function} ParseOperand(tokens)
\IF{next token is specific operator}
\STATE \quad $(left, tokens) \gets \textsc{ParseNextExpression}(tokens)$
\STATE \quad $(right, tokens) \gets \textsc{ParseOperand}(tokens)$
\STATE \quad \textbf{return} $(\textsc{SpecificNode}(, expr), tokens)$
\ELSE
\STATE \quad \textbf{return} $(\textsc{EmptyOperand}(), tokens)$
\ENDIF
\STATE
\STATE \textbf{function} ParseNextExpression(tokens) ...
\end{algorithmic}
\end{algorithm}
\caption{Recursive descent parser demonstrating recursion and precedence.}
\label{compressedParser}
\end{figure}

Fig.\ref{plotGenAlgo} Demonstrates how plots data is generated. In the actual implementation, expressions are stored in the interpreter symbol table during parsing and are resolved for different values of $x$ at execution time. Values for $x$ are inserted as values within the symbol table in each iteration. In order to facilitate multiple lines, the real implementation features a 2 dimensional array of plot points, where each sequence represents a single line to be plotted.

\begin{figure}[H]
\begin{algorithm}[H]
\caption{Generate plot points from expression}
\begin{algorithmic}[1]
\STATE $\mathit{f} \gets \textsc{Expression}$
\STATE $\mathit{minX} \gets -10.0$
\STATE $\mathit{maxX} \gets 10.0$
\STATE $\mathit{step} \gets 0.1$
\STATE $x \gets \mathit{maxX}$
\WHILE{$x > \mathit{minX}$}
    \STATE $x \gets x - \mathit{step}$
    \STATE $y \gets \textsc{Compute}(f(x))$
    \STATE \textsc{AppendResult}$(x, y)$
\ENDWHILE
\end{algorithmic}
\end{algorithm}
\caption{Algorithm to generate plot points. $minX$, $maxX$, and $step$ are set as example values.}
\label{plotGenAlgo}
\end{figure}

Fig.\ref{plotInterGenAlgo} Demonstrates how a new interference pattern can be generate from a collection of line plot sequences in a simple manner.

\begin{figure}[H]
\begin{algorithm}[H]
\caption{Generate interference pattern based on existing plots}
\begin{algorithmic}[1]
\STATE $\mathit{lines} \gets \textsc{ExistingPlotSequences}$
\STATE $\mathit{pattern} \gets \textsc{NewPlotSequence}$

\FOR{each index $i$ of $\mathit{lines}[0]$}
    \STATE $x \gets \mathit{lines}[0][i].x$
    \STATE $y \gets 0$
    \FOR{each $\mathit{line}$ in $\mathit{lines}$}
        \STATE $y \gets y + \mathit{line}[i].y$
    \ENDFOR
    \STATE $\mathit{pattern}.\textsc{AppendResult}(x, y)$
\ENDFOR
\end{algorithmic}
\end{algorithm}
\caption{Algorithm to generate interference patterns.}
\label{plotInterGenAlgo}
\end{figure}

\subsection{Testing}

Extensive testing as been performed for all aspects of the system including the interpreter, GUI and plotting functionality.
\newline
\newline
The interpreter was validated through comprehensive unit testing. Both valid and inputs with specific focus on syntactic correctness and adherence to the grammar BNF. Test cases were designed to assess operator precedence and associativity as well as syntactic errors.
An automated build and test pipeline was implemented for project pull requests. This pipeline help to detect regressions early and keep development fluid. 
Tables \ref{TableTest1}, \ref{TableTest2}, \ref{TableTest3}, \ref{TableTest4} and \ref{TableTest5} contain the automated unit test cases.
\newline
\newline
Structured manual testing of the GUI was performed in order to determine functionality. Core UI functions were run and outputs checked against expected results. WPF based GUI testing solutions such as \cite{WPFPilot:2026}, which allows you to inspect specific UI elements, were considered, as additional automated testing would make it easier and more practical to programmatically test the GUI more exhaustively. We decided against integrating these types of tools as the time cost could not be justified as the GUI is too simple.
A similar manner was also used to determine plotting correctness where we plotted a known function and manually calculated the correctness of Y values at a series of known points of X.
Tables \ref{TableGUITest1} and \ref{TablePlotTest1} contain the manual test cases.
\newline
\newline
This overall testing methodology was informed by time cost to benefit analysis and previous industry experience. The automated test pipeline proved invaluable as it caught a number of regression issues throughout the development process.

\chapter{Discussion, conclusion and future work}

Briefly discuss  your achievements and put them in perspective with the MoSCoW analysis you specified in Table \ref{Table1}. Also discuss future developments and how you see the deliverable improving if more time could be spent. Note that this section should not be used as a medium to vent frustrations on whatever did not work out (group issues, not enough time, illness, etc.) as this should be dealt with separately - keep it professional!

\bibliographystyle{apalike}
\bibliography{References}

\appendix
\chapter{Contributions}

\section{Individual Contributions}

\begin{table}[H]
\begin{tabular}{|p{1.2in}|p{1.2in}|} \hline
Name & Contribution \\ \hline
Anthony de Cruz & 50\% \\ \hline
Mason Buckle & 50\% \\ \hline
\end{tabular}
\label{TableContribution}
\end{table}

Both members equally contributed to the project. We both worked on designing the application/BNF in equal time as well as performing testing of the application. Anthony developed most of the F\# interpreter and Mason developed the plotting and GUI in C\#. This complete report was also written in equal parts by both members with Mason writing chapters 1, 2 and 3 and Anthony writing chapters 4 and 5.

\chapter{Testing}
\label{app:test}
\section{Arithmetic expression testing}

\begin{table}[H]
\caption{Original set of arithmetic expression tests. Note that floating pointing values are accurate to three decimal places for the fractional part. ResE is expected result and ResA is actual result.
\\}
\begin{tabular}{|p{1.8in}|p{0.6in}|p{0.6in}|p{0.6in}|p{1.4in}|} \hline
Expression & ResE & ResA& Pass/Fail & Action/comment \\ \hline \hline
$5*3+(2*3-2)/2+6$ & 23 & 23 & PASS &  ... \\ \hline
$9-3-2$ & 4 & 4 & PASS & left assoc.\  \\ \hline
$10/3$ & 3 & 3 & PASS & int division  \\ \hline
$10/3.0$ & 3.333 & 3.333 & PASS & float division \\ \hline
$10\%3$ & 1 & 1 & PASS & \\ \hline
$10 - -2$ & 12 & 12 & PASS & unary minus\\ \hline
$-2 + 10$ & 8 & 8 & PASS & \\ \hline
$3*5\verb|^|(-1+3)-2\verb|^|2*-3$ & 87 & 87 & PASS & power test \\ \hline
$-3\verb|^|2$ & -9(*) or 9 & 9 & PASS & precedence \\ \hline
$-7\%3$ & 2(*) or -1 & -1 & PASS & precedence (*)Python\\ \hline
$2*3^2$ & 18 & 18 & PASS & precedence pow > mult \\ \hline
$3*5\verb|^|(-1+3)-2\verb|^|-2*-3$ & 75.750 or 75 & 75 & PASS & \\ \hline
$3*5\verb|^|(-1+3)-2.0\verb|^|-2*-3$ & 75.750 & 75.750 & PASS & \\ \hline
$(((3*2--2)))$ & 8 & 8 & PASS & \\ \hline 
$(((3*2--2))$ & Error & Syntax Error & PASS & syntax error \\ \hline
$-((3*5-2*3))$ & -9 & -9 & PASS &  minus expression \\ \hline
$x = 3; (2*x)-x\verb|^|2*5$ & -39 & 39 & PASS & var assign \\ \hline
$x = 3; (2*x)-x\verb|^|2*5/2$ & -16 & -16 & PASS & \\ \hline
$x = 3; (2*x)-x\verb|^|2*(5/2)$ & -12 & -12 & PASS & \\ \hline
$x = 3; (2*x)-x\verb|^|2*5/2.0$ & -16.5 & -16.5 & PASS & \\ \hline
$x = 3; (2*x)-x\verb|^|2*5\%2$ & 5 & 5 & PASS &  \\ \hline
$x = 3; (2*x)-x\verb|^|2*(5\%2)$ & -3 & -3 & PASS &  \\ \hline
\end{tabular}
\label{TableTest1}
\end{table}

\begin{table}[H]
\caption{Boolean expression \& statement tests.
\\}
\begin{tabular}{|p{1.8in}|p{0.6in}|p{0.6in}|p{0.6in}|p{1.4in}|} \hline
Expression & ResE & ResA& Pass/Fail & Action/comment \\ \hline
$5 > 3$ & 1 & 1 & PASS & \\ \hline
$3 > 5$ & 0 & 0 & PASS & \\ \hline
$3 < 5$ & 1 & 1 & PASS & \\ \hline
$5 < 3$ & 0 & 0 & PASS & \\ \hline
$2 == 2$ & 1 & 1 & PASS & \\ \hline
$2 == 1$ & 0 & 0 & PASS & \\ \hline
$2 != 2$ & 0 & 0 & PASS & \\ \hline
$2 != 1$ & 1 & 1 & PASS & \\ \hline
$!1$ & 0 & 0 & PASS & \\ \hline
$!0$ & 1 & 1 & PASS & \\ \hline
$1$ and $1$ & 1 & 1 & PASS & \\ \hline
$0$ and $1$ & 0 & 0 & PASS & \\ \hline
$1$ and $0$ & 0 & 0 & PASS & \\ \hline
$0$ and $0$ & 0 & 0 & PASS & \\ \hline
$5 > 2$ and $10 == 4$ & 0 & 0 & PASS & \\ \hline
$5 > 2$ and $10 != 4$ & 1 & 1 & PASS & \\ \hline
$1$ or $1$ & 1 & 1 & PASS & \\ \hline
$0$ or $1$ & 1 & 1 & PASS & \\ \hline
$1$ or $0$ & 1 & 1 & PASS & \\ \hline
$0$ or $0$ & 0 & 0 & PASS & \\ \hline
$5 > 2$ or $10 == 4$ & 1 & 1 & PASS & \\ \hline
$5 > 2$ or $10 != 4$ & 1 & 1 & PASS & \\ \hline
$>$ & Error & Syntax Error & PASS & \\ \hline
$< 3$ & Error & Syntax Error & PASS & \\ \hline
$!$ & Error & Syntax Error & PASS & \\ \hline
$3 == 5 !=$ & Error & Syntax Error & PASS & \\ \hline
i = 0; while i < 5 \{ i = i + 1; \} y = i; & 5 & 5 & PASS & \\ \hline
i = 7; if i == 7 \{ y = 8; \} & 8 & 8 & PASS & \\ \hline
i = 0; while i < 5 y = i; & Error & Syntax Error & PASS & \\ \hline
i = 0; if i < 5 y = i; & Error & Syntax Error & PASS & \\ \hline
i = 0; while \{ y = i; \} & Error & Syntax Error & PASS & \\ \hline
i = 0; if \{ y = i; \} & Error & Syntax Error & PASS & \\ \hline
\end{tabular}
\label{TableTest2}
\end{table}

\begin{table}[H]
\caption{Expression tests.
\\}
\begin{tabular}{|p{1.8in}|p{0.6in}|p{0.6in}|p{0.6in}|p{1.4in}|} \hline
Expression & ResE & ResA& Pass/Fail & Action/comment \\ \hline \hline
$5 + 3$ & 8 & 8 & PASS & \\ \hline
$200 + 13 + 45$ & 258 & 258 & PASS & \\ \hline
$3 + 1.1$ & 4.1 & 4.1 & PASS & \\ \hline
$5 + 3$ & 8 & 8 & PASS & \\ \hline
$+$ & Error & Syntax Error & PASS & \\ \hline
$+ 3$ & Error & Syntax Error & PASS & \\ \hline
$3 +$ & Error & Syntax Error & PASS & \\ \hline
$3 + 5 +$ & Error & Syntax Error & PASS & \\ \hline
$3 * 3$ & 9 & 9 & PASS & \\ \hline
$8 * 4 * 3$ & 96 & 96 & PASS & \\ \hline
$3 * 1.1$ & 3.3 & 3.3 & PASS & \\ \hline
$3.256 * 1.59$ & 5.177 & 5.177 & PASS & \\ \hline
$*$ & Error & Syntax Error & PASS & \\ \hline
$* 3$ & Error & Syntax Error & PASS & \\ \hline
$3 *$ & Error & Syntax Error & PASS & \\ \hline
$3 * 5 *$ & Error & Syntax Error & PASS & \\ \hline
$6 / 3$ & 2 & 2 & PASS & \\ \hline
$5 / 3.0$ & 1.667 & 1.667 & PASS & \\ \hline
$12 / 3 / 2$ & 2 & 2 & PASS & \\ \hline
$3.2 / 2$ & 1.6 & 1.6 & PASS & \\ \hline
$3.4 / 2.3$ & 1.478 & 1.478 & PASS & \\ \hline
$/$ & Error & Syntax Error & PASS & \\ \hline
$/ 3$ & Error & Syntax Error & PASS & \\ \hline
$3 /$ & Error & Syntax Error & PASS & \\ \hline
$3 / 5 /$ & Error & Syntax Error & PASS & \\ \hline
$3 / 0$ & Error & Divide By Zero & PASS & \\ \hline
$3 / 0.0$ & Error & Divide By Zero & PASS & \\ \hline
\end{tabular}
\label{TableTest3}
\end{table}

\begin{table}[H]
\caption{Expression tests continued.
\\}
\begin{tabular}{|p{1.8in}|p{0.6in}|p{0.6in}|p{0.6in}|p{1.4in}|} \hline
Expression & ResE & ResA& Pass/Fail & Action/comment \\ \hline \hline
$6 \% 3$ & 0 & 0 & PASS & \\ \hline
$5 \% 3$ & 2 & 2 & PASS & \\ \hline
$19 \% 5 \% 3$ & 1 & 1 & PASS & \\ \hline
$3.2 \% 2$ & 1.2 & 1.2 & PASS & \\ \hline
$3.4 \% 2.3$ & 1.1 & 1.1 & PASS & \\ \hline
$\%$ & Error & Syntax Error & PASS & \\ \hline
$\% 3$ & Error & Syntax Error & PASS & \\ \hline
$3 \%$ & Error & Syntax Error & PASS & \\ \hline
$3 \% 5 \%$ & Error & Syntax Error & PASS & \\ \hline
$3 \% 0$ & Error & Divide By Zero & PASS & \\ \hline
$3 \% 0.0$ & Error & Divide By Zero & PASS & \\ \hline
$5\verb|^|2$ & 25 & 25 & PASS & \\ \hline
$5\verb|^|2\verb|^|2$ & 625 & 625 & PASS & \\ \hline
$2\verb|^|1.1$ & 2.144 & 2.144 & PASS & \\ \hline
$\verb|^|$ & Error & Syntax Error & PASS & \\ \hline
$\verb|^| 3$ & Error & Syntax Error & PASS & \\ \hline
$3 \verb|^|$ & Error & Syntax Error & PASS & \\ \hline
$3 \verb|^| 5 \verb|^|$ & Error & Syntax Error & PASS & \\ \hline
$-2$ & -2 & -2 & PASS & \\ \hline
$5 - - 2$ & 7 & 7 & PASS & \\ \hline
$5 +- 2$ & 3 & 3 & PASS & \\ \hline
$5 +-- 3$ & 8 & 8 & PASS & \\ \hline
$2 \verb|^|- 2$ & 0 & 0 & PASS & \\ \hline
$2 \verb|^|-- 2$ & 4 & 4 & PASS & \\ \hline
$-$ & Error & Syntax Error & PASS & \\ \hline
$5 ++- 3$ & Error & Syntax Error & PASS & \\ \hline
$2 \verb|^| -$ & Error & Syntax Error & PASS & \\ \hline
$2--+--2$ & Error & Syntax Error & PASS & \\ \hline
\end{tabular}
\label{TableTest4}
\end{table}

\begin{table}[H]
\caption{Lexer tests for operators, floating point numbers, and symbols.
\\}
\begin{tabular}{|p{1.0in}|p{1.3in}|p{1.3in}|p{0.6in}|p{1.2in}|} \hline
Expression & ResE & ResA& Pass/Fail & Action/comment \\ \hline \hline
3 + 5 & [Int 3; Add; Int 5] & [Int 3; Add; Int 5] & PASS & \\ \hline
1 * 2 & [Int 1; Mul; Int 2] & [Int 1; Mul; Int 2] & PASS & \\ \hline
3 \verb|^| 8 & [Int 3; Pwr; Int 8] & [Int 3; Pwr; Int 8] & PASS & \\ \hline
3 Â£ 4 & Error & Syntax Error & PASS & \\ \hline
5 5 : & Error & Syntax Error & PASS & \\ \hline
3.8 & [Flt 3.8] & [Flt 3.8] & PASS & \\ \hline
3.008 & [Flt 3.008] & [Flt 3.008] & PASS & \\ \hline
3.811 & [Flt 3.811] & [Flt 3.811] & PASS & \\ \hline
0.811 & [Flt 0.811] & [Flt 0.811] & PASS & \\ \hline
100.001 & [Flt 100.001] & [Flt 100.001] & PASS & \\ \hline
7. & Error & Syntax Error & PASS & \\ \hline
.7 & Error & Syntax Error & PASS & \\ \hline
5 .2 & Error & Syntax Error & PASS & \\ \hline
2. 5 & Error & Syntax Error & PASS & \\ \hline
x & [Sym "x"] & [Sym "x"] & PASS & \\ \hline
y & [Sym "y"] & [Sym "y"] & PASS & \\ \hline
varname & [Sym "varname"] & [Sym "varname"] & PASS & \\ \hline
myvar & [Sym "myvar"] & [Sym "myvar"] & PASS & \\ \hline
3 + variable & [Int 3; Add; SymT "variable"] & [Int 3; Add; Sym "variable"] & PASS & \\ \hline
\end{tabular}
\label{TableTest5}
\end{table}

\section{GUI testing}

\begin{table}[H]
\caption{A series of manual/visual tests to determine functionality.
\\}
\begin{tabular}{|p{1.8in}|p{1.8in}|p{1.4in}|p{0.6in}|} \hline
Action & ResE & ResA & Pass/Fail \\ \hline \hline
Write code into main text field and hit the run button. & The program is executed, with expected plots and output. & The program is executed as expected. & PASS \\ \hline
Press the clear button. & Any existing plots should be cleared. & Existing plots are cleared. & PASS  \\ \hline
Press the open button. & A dialogue is shown allowing the user to select a text file to load into the buffer. & A file is loaded into the text buffer via a dialogue. & PASS \\ \hline
Press the save button. & The existing text buffer should be saved to a text file via a dialogue. & The current text buffer is written to a text file. & PASS \\ \hline
Press the help button. & The tutorial window should be displayed. & The tutorial window is displayed. & PASS \\ \hline
\end{tabular}
\label{TableGUITest1}
\end{table}

\section{Plot testing}

\begin{table}[H]
\caption{A Series of manual/visual tests to determine functionality.
\\}
\begin{tabular}{|p{1.8in}|p{1.8in}|p{1.4in}|p{0.6in}|} \hline
Action & ResE & ResA& Pass/Fail \\ \hline \hline
Execute "plot x + 2;" and set minimum X = -10, maximum X = 10, resolution = 10. Observe the plotted values in the GUI. & Where Y = 0, X should be 2. Where Y = 1 X should be 3. & Where Y = 0, X = 2. Where Y = 0, X = 3. & PASS \\ \hline
Execute "plot x\verb|^|2 - 2;" and set minimum X = -10, maximum X = 10, resolution = 10. Observe the plotted values in the GUI. & Where Y = 0, X = -2. Where Y = 5, X = 23. & Where Y = 0, X = -2. Where Y = 0, X = 23. & PASS \\ \hline
\end{tabular}
\label{TablePlotTest1}
\end{table}

\chapter{Other Materials}

The program found in Fig.\ref{gui02}.
\begin{verbatim}
func myCubicLine = x^3 + x^2 + x - 3;   # Define a cubic function.

let i = 0;
while i < 4 {                   # A loop with a boolean comparison.
    let i = i + 1;

    plot myCubicLine + 1.5^i;    # Plot a series of cubic lines.

    if i == 3 {   # Plot a quadratic line when i is 3.
        plot x^2 + x - 1.5 * i;  
    }
}
\end{verbatim}
\label{Script1}

\begin{figure}[htb]
\includegraphics[width=0.9 \columnwidth]{CodeSnip1.png}
\caption{The real F\# implementation for plot point calculation.}
\label{codeSnip1}
\end{figure}

\end{document}

